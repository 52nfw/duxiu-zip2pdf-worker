# 修复说明

##问题1: JSON解析错误
错误：`Unexpected token '<', "<!DOCTYPE "... is not valid JSON`

**原因**：服务器返回了HTML错误页面而不是JSON

**修复位置**：前端JavaScript，在转换请求后添加响应类型检查

```javascript
// 在 startConversion 函数中修改
const convertResponse = await fetch('/convert', {
  method: 'POST',
  headers: convertHeaders,
  body: JSON.stringify({ key: uploadedFileKey })
});

// 添加内容类型检查
const contentType = convertResponse.headers.get('content-type');
if (!contentType || !contentType.includes('application/json')) {
  const text = await convertResponse.text();
  throw new Error('服务器返回了非JSON响应，可能是内部错误: ' + text.substring(0, 100));
}

if (!convertResponse.ok) {
  const error = await convertResponse.json();
  // ...
}
```

## 问题2: 子文件夹图片识别

**现状**：只识别根目录图片
**需求**：递归识别所有层级的图片

**修复代码**（替换index.js第810-860行）：

```javascript
// 提取并分类图片文件（支持子文件夹）
const imageFiles = [];
let hasCover = false;
let cover = null;
let backCover = null;

// 递归查找所有图片文件，不管在哪个目录层级
for (const [fullPath, data] of Object.entries(files)) {
    // 跳过目录项
    if (data.length === 0 || fullPath.endsWith('/') || fullPath.endsWith('\\\\')) {
        continue;
    }

    const lowerPath = fullPath.toLowerCase();
    
    // 检查文件扩展名是否是图片
    const isImage = lowerPath.endsWith('.pdg') || lowerPath.endsWith('.jpg') ||
        lowerPath.endsWith('.jpeg') || lowerPath.endsWith('.png') ||
        lowerPath.endsWith('.bmp') || lowerPath.endsWith('.tif') ||
        lowerPath.endsWith('.tiff') || lowerPath.endsWith('.gif');

    if (!isImage) continue;

    // 提取文件名（不含路径）
    const fileName = fullPath.replace(/\\\\/g, '/').split('/').pop();
    const lowerFileName = fileName.toLowerCase();

    // 检查封面封底（不管在哪个文件夹）
    if (lowerFileName.includes('cov001') || lowerFileName.startsWith('cov001')) {
        cover = { filename: fullPath, data, isCover: true };
        hasCover = true;
        console.log(`检测到封面: ${fullPath}`);
    } else if (lowerFileName.includes('cov002') || lowerFileName.startsWith('cov002')) {
        backCover = { filename: fullPath, data, isBackCover: true };
        hasCover = true;
        console.log(`检测到封底: ${fullPath}`);
    } else {
        imageFiles.push({ filename: fullPath, data });
    }
}

if (imageFiles.length === 0 && !cover && !backCover) {
    return new Response(JSON.stringify({ 
        error: 'ZIP文件中没有找到图片文件',
        hint: '请确保ZIP中包含PDG、JPG、PNG等图片格式'
    }), {
        status: 400,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
    });
}

// 自然排序内容页（按完整路径排序）
imageFiles.sort((a, b) => {
    return a.filename.localeCompare(b.filename, undefined, {
        numeric: true,
        sensitivity: 'base'
    });
});

// 组装最终顺序：封面 + 内容 + 封底
const finalFiles = [];
if (cover) finalFiles.push(cover);
finalFiles.push(...imageFiles);
if (backCover) finalFiles.push(backCover);

console.log(`文件排序完成: 封面=${cover ? '是' : '否'}, 内容=${imageFiles.length}页, 封底=${backCover ? '是' : '否'}`);
```

## 手动修复步骤

1. ** 打开 index.js**
2. **找到第810行左右**，搜索 `// 提取并分类图片文件`
3. **替换整段代码**（从 `const coverFile` 到 `console.log(`文件排序完成`）
4. **保存文件**
5. **重新部署**：`npm run deploy`

## 改进点

### 支持的ZIP结构

**之前只支持**：
```
book.zip
├── 001.pdg
├── 002.pdg
└── 003.pdg
```

**现在支持**：
```
book.zip
├── subfolder/
│   ├── 001.pdg
│   ├── 002.pdg
│   └── 003.pdg
└── cov001.pdg

或

book.zip
├── BookName第1卷/
│   ├── 001.jpg
│   ├── 002.jpg
│   └── 003.jpg
└── cov001.jpg
```

### 新增功能

1. **递归搜索** - 查找所有子文件夹中的图片
2. **跳过目录** - 忽略空文件和目录项
3. **更多格式** - 新增支持GIF格式
4. **路径规范化** - 统一处理Windows和Linux路径
5. **详细日志** - 显示完整文件路径
6. **错误提示** - 提示用户文件格式要求

## 测试建议

上传以下类型的ZIP测试：

1. ✅ 根目录直接是图片
2. ✅ 一层子文件夹 + 图片
3. ✅ 多层子文件夹 + 图片  
4. ✅ 混合结构（部分在根，部分在子文件夹）
5. ✅ 带封面封底的ZIP

## 部署后验证

1. 上传测试ZIP
2. 查看浏览器Console日志
3. 确认看到类似：
   ```
   检测到封面: folder/cov001.pdg
   文件排序完成: 封面=是, 内容=245页, 封底=是
   ```
